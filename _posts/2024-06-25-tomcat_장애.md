---
title: 메모리 분석을 통한 Tomcat 성능 튜닝(수정중)
date: 2024-06-25 11:30:00 +09:00
categories: [Tomcat, memory]
tags: [tomcat, heap, memory]
---

어느날 tomcat 서비스가 비정상적으로 종료된 것을 확인하였습니다.  
zabbix 모니터링을 통해서 웹 시나리오에 등록된 url 알럿 발생 시간을 확인 후 tomcat log를 분석하였습니다.  
해당 시간에 발생한 로그에는 아래와 같았습니다.

```bash
java.lang.OutOfMemoryError: unable to create new native thread
.
.
.
```

처음에 OutOfMemoryError 를 확인 후 OS의 전체 메모리가 부족한 현상이 아닌가 싶어 zabbix에서 해당 시간 메모리 사용량을 확인해보았습니다.

![outofmemory](../assets/img/posts_img/tomcat_error/zabbix-availableMeM.png)

분명 해당시간대에 메모리가 감소한 것을 알 수 있으나 메모리가 0에 가깝게 사용하지는 않고 있는 것을 확인할 수 있습니다.

```bash
$ free -mh
              total        used        free      shared  buff/cache   available
Mem:           125G         35G        665M         11M         89G         89G
Swap:           63G        1.0G         63G
```

현재 서버의 평소 메모리 사용량입니다.  
total 125G의 메모리 중에 35G 사용하고 있습니다. 또한 buff/cache는 89G로 잡혀 있으며, buff/cache에 잡히지 않은 사용가능한 메모리는 free로 665M 여유가 있습니다.  
그리고 중요한 값인 available 이 89G 입니다. 이 값은 전체 메모리에서 필요시 사용가능한 메모리 가용량을 뜻합니다.  
free 와 같이 아예 사용중이지 않은 값이 아니라 사용중이더라도 바로 회수해서 사용가능한 영역까지 전부 계산한 값으로 커널에서 아래와 같이 계산한다고 합니다.

```bash
MemAvailable = free + (cached - min(cached / 2, low_wmark_pages)) + (reclaimable - unreclaimable_slabs)
```

위의 요소들을 한번 확인해보면,

- free = free 메모리 값
- cached = 페이지 케시 메모리
- low_wmark_pages = 시스템에서 최소한으로 유지해야되는 페이지 수
- reclaimable = 회수 가능한 슬랩 메모리
- unreclaimable_slabs = 회수 불가능한 슬랩 메모리
  ```bash
  *_slab 이란?_
  _커널 데이터 객체의 생성/파괴의 오버헤드를 줄이기 위해 자주 사용되는 오브젝트들을 미리 만들어서 관리하는 역할을 한다._
  ```

위 계산으로 단순하게 free, share, buff/cache의 값을가지고 판단할 수는 없지만 Available 값이 필요시 할당 받을 수 있는 메모리라는 것은 알 수 있다.  
앞서 본 내용을 바탕으로 현재 OS 영역에서의 메모리 부족이 아니라는 것을 알 수 있습니다.

다시 log 메시지로 돌아와서,  
실제 OutOfMemoryError 이후에 오는 문구인 "unable to create new native thread"를 확인해봐야 됩니다.  
이는 java에서 thread를 생성할 때 생성할 수 없다는 메시지입니다.  
java에서 thread를 생성할 시 필요한 영역이 존재합니다. 그건 바로 Heap 메모리 입니다.  
heap 영역은 JVM(Java Virtual Machine)이 런타임 동안 생성하는 객체와 배열을 저장하는 메모리 영역을 뜻합니다.

위 내용만 봐도 어떤 문제일지 어느정도 감이 잡히지요?  
바로, Heap 영역이 부족하여 발생한 에러인 것이라고 유추할 수 있습니다.  
그럼 java 전체의 메모리 영역에 대해서 어떻게 구성되있는지 확인하고 분석을 해봅시다.

## JVM

우선 JVM이 무엇인지 부터 알아야됩니다.  
JVM이란 Java Virtual Machine로 자바의 가상머신입니다. java의 바이트 코드를 해석하고 실행하는 역할을 수행합니다.
Java 프로그램은 JVM이란 가상머신안에서 동작하기 때문에 운영체제 상관없이 JAVA를 동작 시킬 수 있다.

## java의 다이어그램

자바 프로그램이 동작하는 과정을 다이어그램으로 살펴보겠습니다.
![java_diagram](../assets/img/posts_img/tomcat_error/java_diagram.png)

1. 개발자가 자바 소스를 작성하여 저장하면 우선 '.java' 라는 파일로 저장합니다.
2. 그리고 javac 라는 컴파일러를 통해서 '.class' 확장자를 갖는 바이트코드 파일로 변환합니다.  
   (_**java의 바이트코드란** jvm에서 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다._)
3. 그 후, 컴파일이 완료된 java프로그램을 실행시키면 JVM은 운영체제로부터 프로그램 실행을 위한 메모리를 항당 받습니다.(그 중에 개발자가 작성한 프로그램이 실제로 동작하는 메모리 영역을 Java Runtime Data 라고 부름)
4. JVM 안의 Class Loader가 .class 파일에서 바이트코드를 읽어서 메모리에 올린다.
5. Execution Engine은 기본적으로 인터프리터 방식으로 바이트 코드를 실행한다.(바이트 코드를 한줄씩 기계어로 번역하여 프로그램을 실행.)
   - 인터프리터 : 바이트코드를 기계어로 번역하는 역할을 한다.
   - JIT : 인터프리터가 읽어온 바이트코드를 캐싱해두고 적절한 시점에 기계어로 번역한다.(인터프리터만을 통해 번역하면 성능이 떨어지기 때문에 캐싱하여 번역을 도운다.)
   - GC(Garbage Collector) : java에서 메모리 관리를 자동으로 해주는 중요한 요소중 하나로 더이상 사용되지 않는 메모리 영역을 탐지하여 비워주는 역할을 한다.
6. 마지막으로, JNI(Java Native Interface)는 자바 프로그램 동작시 다른 언어로 작성된 라이브러리가 존재할 수 있으며 그런 라이브러리를 자바 환경에서 동작하도록 지원하는 역할을 한다.

## [분석]

## java-jdk의 기본 툴들 활용

java-jdk를 설치할 경우 기본적으로 설치되는 3가지 툴이 존재한다.
"jps, jmap, jhat"

### jps 란?

우리가 리눅스 상에서 기본적으로 프로세스들을 확인하기 위해서 사용하는 명령어가 있다. 바로, "ps" 라는 명령어이다.
java에서도 JVM의 프로세스들을 확인 할 수 있는 명령어가 바로 "jps" 이다

```bash
$ jps
31265 Jps
10498 Bootstrap

# jps -v 옵션을 추가할 경우 jvm 파라미터들도 같이 출력된다.
# 10498 Bootstrap -Djava.util.logging.config.file=/usr/local/tomcat/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dorg.apache.catalina.security.SecurityListener.UMASK=0027 -Dignore.endorsed.dirs= -Dcatalina.base=/usr/local/tomcat -Dcatalina.home=/usr/local/tomcat -Djava.io.tmpdir=/usr/local/tomcat/temp
# 31450 Jps -Denv.class.path=.:/usr/local/java/lib/tools.jar:/usr/local/tomcat/lib/jsp-api.jar:/usr/local/tomcat/lib/servlet-api.jar:/usr/local/tomcat/lib/mysql-connector-java-5.1.46-bin.jar -Dapplication.home=/usr/local/java -Xms8m
```

### jmap 이란?

jvm의 맵을 보여주는 기본 분석 툴이다. 자바의 힙 메모리 등의 정보를 얻을 수 있으며, 메모리 dump를 떠서 분석이 가능하다.

1. heap memory 정보 확인

```bash
$ jmap -heap 10498

Attaching to process ID 10498, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.181-b13

using thread-local object allocation.
Parallel GC with 38 thread(s)

Heap Configuration:
   MinHeapFreeRatio         = 0
   MaxHeapFreeRatio         = 100
   MaxHeapSize              = 8357150720 (7970.0MB)
   NewSize                  = 174587904 (166.5MB)
   MaxNewSize               = 2785542144 (2656.5MB)
   OldSize                  = 349700096 (333.5MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 993001472 (947.0MB)
   used     = 325079288 (310.01976776123047MB)
   free     = 667922184 (636.9802322387695MB)
   32.73703989030945% used
From Space:
   capacity = 5242880 (5.0MB)
   used     = 1147064 (1.0939254760742188MB)
   free     = 4095816 (3.9060745239257812MB)
   21.878509521484375% used
To Space:
   capacity = 5242880 (5.0MB)
   used     = 0 (0.0MB)
   free     = 5242880 (5.0MB)
   0.0% used
PS Old Generation
   capacity = 1728053248 (1648.0MB)
   used     = 1146590360 (1093.473777770996MB)
   free     = 581462888 (554.5262222290039MB)
   66.35156418513326% used

53060 interned Strings occupying 6398256 bytes.
```

2. jvm 프로세스의 메모리 통계 확인

```bash
$ jmap -histo 10498

```

### jhat 이란?
